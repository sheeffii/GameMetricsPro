#!/bin/bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
REGION="${AWS_REGION:-us-east-1}"
CLUSTER_NAME="gamemetrics-dev"
TERRAFORM_DIR="terraform/environments/dev"
INFRA_OUTPUT_FILE=".infra-output.env"

echo -e "${GREEN}════════════════════════════════════════════${NC}"
echo -e "${GREEN}  GameMetrics Infrastructure Deployment${NC}"
echo -e "${GREEN}  (AWS + EKS + Databases + Kafka Operators)${NC}"
echo -e "${GREEN}════════════════════════════════════════════${NC}"
echo ""

# Function to print status
print_status() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

# Check prerequisites
echo -e "${BLUE}Checking prerequisites...${NC}"
command -v aws >/dev/null 2>&1 || { print_error "AWS CLI not installed"; exit 1; }
command -v terraform >/dev/null 2>&1 || { print_error "Terraform not installed"; exit 1; }
command -v kubectl >/dev/null 2>&1 || { print_error "kubectl not installed"; exit 1; }
print_status "All prerequisites installed"
echo ""

# Step 1: Deploy Terraform infrastructure
echo -e "${GREEN}Step 1: Deploying AWS Infrastructure via Terraform${NC}"
cd "$TERRAFORM_DIR"

print_info "Initializing Terraform..."
terraform init -upgrade -no-color

print_info "Applying infrastructure..."
terraform apply -auto-approve -no-color

# Get outputs
export EKS_CLUSTER_NAME=$(terraform output -raw eks_cluster_name 2>/dev/null || echo "$CLUSTER_NAME")
export RDS_ENDPOINT=$(terraform output -raw rds_endpoint 2>/dev/null || echo "")
export REDIS_ENDPOINT=$(terraform output -raw elasticache_primary_endpoint 2>/dev/null || echo "")
export ECR_URL=$(terraform output -json 2>/dev/null | jq -r '.ecr_repository_urls.value["event-ingestion-service"]' 2>/dev/null || echo "")
export VPC_ID=$(terraform output -raw vpc_id 2>/dev/null || echo "")

# Save infrastructure outputs for later use
cat > "../../$INFRA_OUTPUT_FILE" << EOF
# Infrastructure Outputs - Generated by deploy-infra-only.sh
REGION=$REGION
EKS_CLUSTER_NAME=$EKS_CLUSTER_NAME
RDS_ENDPOINT=$RDS_ENDPOINT
REDIS_ENDPOINT=$REDIS_ENDPOINT
ECR_URL=$ECR_URL
VPC_ID=$VPC_ID
DEPLOYED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
EOF

cd - > /dev/null
print_status "Infrastructure deployed"
echo ""

# Step 2: Configure kubectl
echo -e "${GREEN}Step 2: Configuring kubectl${NC}"
aws eks update-kubeconfig --region "$REGION" --name "$EKS_CLUSTER_NAME"
print_status "kubectl configured"
echo ""

# Step 3: Wait for nodes to be ready
echo -e "${GREEN}Step 3: Waiting for EKS nodes${NC}"
timeout=300
elapsed=0
while [ $elapsed -lt $timeout ]; do
    ready_nodes=$(kubectl get nodes --no-headers 2>/dev/null | grep -c "Ready" || echo "0")
    if [ "$ready_nodes" -ge 3 ]; then
        print_status "All 3 nodes are ready"
        break
    fi
    echo "  Waiting for nodes... ($ready_nodes/3 ready)"
    sleep 10
    elapsed=$((elapsed + 10))
done

if [ $elapsed -ge $timeout ]; then
    print_error "Timeout waiting for nodes"
    exit 1
fi
echo ""

# Step 4: Deploy Kubernetes infrastructure (namespaces, RBAC, CRDs, operators)
echo -e "${GREEN}Step 4: Deploying Kubernetes infrastructure components${NC}"
print_info "Applying kustomization..."
kubectl apply -k k8s/
print_status "K8s infrastructure deployed"
echo ""

# Step 5: Wait for Strimzi operator
echo -e "${GREEN}Step 5: Waiting for Strimzi Operator${NC}"
kubectl wait --for=condition=available --timeout=300s deployment/strimzi-cluster-operator -n kafka 2>/dev/null || print_warning "Strimzi operator timeout"
print_status "Strimzi operator ready"

# Wait for CRDs to be established
print_info "Waiting for Kafka CRDs to be established..."
for crd in kafka kafkatopic kafkanodepool; do
  kubectl wait --for condition=established --timeout=300s crd/"${crd}s.kafka.strimzi.io" 2>/dev/null || print_warning "CRD ${crd} timeout"
done
print_status "All Kafka CRDs established"
echo ""

# Step 6: Apply Kafka cluster and topics
echo -e "${GREEN}Step 6: Deploying Kafka cluster and topics${NC}"
max_retries=3
retry=0
while [ $retry -lt $max_retries ]; do
  if kubectl apply -f k8s/kafka/kafka-cluster.yaml 2>/dev/null && \
     kubectl apply -f k8s/kafka/topics.yaml 2>/dev/null; then
    print_status "Kafka cluster and topics applied"
    break
  else
    retry=$((retry + 1))
    if [ $retry -lt $max_retries ]; then
      echo "  Retrying Kafka resources ($retry/$max_retries)..."
      sleep 10
    else
      print_warning "Failed to apply Kafka resources after $max_retries retries"
    fi
  fi
done
echo ""

# Step 7: Wait for Kafka cluster
echo -e "${GREEN}Step 7: Waiting for Kafka Cluster${NC}"
kubectl wait --for=condition=ready --timeout=600s pod -l strimzi.io/cluster=gamemetrics-kafka -n kafka 2>/dev/null || print_warning "Kafka cluster timeout"
print_status "Kafka cluster ready"
echo ""

# Step 8: Verify Kafka topics
echo -e "${GREEN}Step 8: Verifying Kafka Topics${NC}"
kubectl get kafkatopic -n kafka 2>/dev/null || echo "Topics not yet available"
echo ""

# Step 9: Update Kubernetes secrets from AWS
echo -e "${GREEN}Step 9: Updating Kubernetes secrets from AWS Secrets Manager${NC}"
bash "$(dirname "$0")/update-secrets-from-aws.sh" "$REGION"
print_status "Kubernetes secrets updated"
echo ""

# Summary
echo -e "${GREEN}════════════════════════════════════════════${NC}"
echo -e "${GREEN}  Infrastructure Deployment Complete${NC}"
echo -e "${GREEN}════════════════════════════════════════════${NC}"
echo ""
echo "Infrastructure Details:"
echo "  Region: $REGION"
echo "  EKS Cluster: $EKS_CLUSTER_NAME"
echo "  RDS Endpoint: $RDS_ENDPOINT"
echo "  Redis Endpoint: $REDIS_ENDPOINT"
echo "  ECR URL: $ECR_URL"
echo "  VPC ID: $VPC_ID"
echo ""
echo "Kubernetes Cluster Status:"
echo "  Nodes: $(kubectl get nodes --no-headers 2>/dev/null | wc -l)"
echo "  Namespaces: $(kubectl get ns --no-headers 2>/dev/null | wc -l)"
echo "  Kafka Brokers: $(kubectl get pods -n kafka -l strimzi.io/cluster=gamemetrics-kafka --no-headers 2>/dev/null | wc -l)"
echo "  Kafka Topics: $(kubectl get kafkatopic -n kafka --no-headers 2>/dev/null | wc -l)"
echo ""
echo "Access Kafka UI:"
echo "  kubectl port-forward -n kafka svc/kafka-ui 8080:8080"
echo "  Then open: http://localhost:8080"
echo ""
echo "Next Steps:"
echo "  1. Deploy applications: bash scripts/deploy-apps-to-k8s.sh"
echo "  2. Monitor cluster: kubectl get all -A"
echo "  3. Check CI/CD: GitHub Actions will auto-deploy on code push"
echo ""
print_status "Infrastructure ready for application deployment!"
